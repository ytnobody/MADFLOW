# MADF（Multi-Agent Development Flow）要件定義書

## 1. コンセプト

本フレームワークは、AIエージェントの並列処理能力を最大限に引き出しつつ、コンテキストオーバーフローや情報の錯綜を防ぐために設計された、**「動的特務チーム型」**の開発フローである。

## 2. エージェントの役割と責任 (Role & Responsibility)

| 階層 | ロール | 役割詳細 | 窓口・権限 |
| --- | --- | --- | --- |
| **統括** | **監督 (Superintendent)** | プロジェクトの全権。アーキテクトからのトスアップに対する自律的判断。新しくopenになったイシューをアーキテクトに知らせる。チャットログを分析して頻出するボトルネックの解消をイシュー化する。 | **対人間 (Issueコメント)**、対アーキテクト |
| **実行(N)** | **アーキテクト** | 設計図の作成、Issueへの仕様記述。エンジニアの疑問への回答。 | 対監督、対エンジニア |
| **実行(N)** | **エンジニア** | 設計に基づくコード実装。 | 対アーキテクト |
| **実行(N)** | **レビュアー** | コード品質・仕様適合性の検証。NG時はエンジニアへ戻す。 | 対エンジニア、対RM |
| **統合** | **リリースマネージャー (RM)** | `develop` / `main` ブランチの管理、マージ、リリース。 | 対レビュアー |

## 3. 通信プロトコル

### 3.1. メンション付き共有チャットログ

* すべてのエージェント間の通信は、ローカルの共有テキストファイル（チャットログ）上で行われる。
* **フォーマット**: `[@宛先] [発信者]: [本文]`
* すべてのエージェントはこのログを常時監視し、自分宛のメンションに対してのみ応答・アクションを行う。

### 3.2. 垂直型エスカレーション（鎖の原則）

情報の混乱を防ぐため、質問・報告のラインを以下に限定する。

* **人間 ↔ 監督**: Issueコメントを通じてやり取り。
* **エンジニア ↔ アーキテクト**: 実装上の疑問のみ。
* **アーキテクト ↔ 監督**: 仕様の不備や判断が必要な事項、プロジェクト全体の影響範囲やリソース管理。

全体としては以下のような流れとなる。

人間 <-> 監督 <-> アーキテクト <-> エンジニア <-> レビュアー <-> リリースマネージャー

アーキテクト、エンジニア、レビュアーは3エージェントで1つの特務チームとなる。

## 4. 実行サイクルとブランチ戦略

### 4.1. 動的チームのライフサイクル

1. **生成**: 監督が特定のイシューに対し、アーキテクト、エンジニア、レビュアーを1名ずつアサインし特務チーム(N)を編成。
2. **設計**: アーキテクトが `feature` ブランチを作成し、設計内容をIssueに記述。
3. **実装**: エンジニアがコードを書き、レビュアーが承認。
4. **解散**: リリースマネージャーが `develop` ブランチへマージ完了後、当該チーム(N)は消滅する。

### 4.2. 環境管理

* **main**: 本番環境。RMのみが操作。
* **develop**: 開発統合環境。人間による動作確認対象。
* **feature/issue-ID**: 各特務チームの作業環境。

## 5. コンテキスト維持プロトコル (8-Minute Reset)

AIの性能低下を防ぐため、以下の手順を強制する。

1. **タイマー監視**: 全エージェントは自身の動作時間を計測し、**8分**経過時に作業を中断。
2. **作業メモの蒸留**: 以下の4項目を「作業メモ」としてログに出力する。
* 現在の状態、決定事項、未解決の課題、次の一手。


3. **リフレッシュ**: コンテキスト（セッション）を一度完全に破棄。
4. **再ロード**: 「元の依頼内容」と「直近の作業メモ」のみを読み込み、作業を再開する。

## 6. 人間の役割

* **Issueの発行**: `develop` ブランチでの動作確認に基づき、新規要件やバグを起票。
* **最終意思決定**: 監督からIssueコメントで求められた判断（Yes/No、数値等）への回答。
* **成果物の確認**: `develop` ブランチに統合された機能の最終QA。
